#include "psyco.h"
#include "psyfunc.h"
#include "codemanager.h"
#include "selective.h"
#include "dispatcher.h"
#include "Python/pycompiler.h"

#define PSYCO_INITIALIZATION
#include "initialize.h"  /* generated by files.py */


 /***************************************************************/
/***   Implementation of the '_psyco' built-in module          ***/
 /***************************************************************/

DEFINEVAR PyObject* PyExc_PsycoError;
static PyObject* CPsycoModule;


DEFINEFN
PyObject* psyco_thread_dict()
{
  static PyObject* key = NULL;
  PyObject* dict = PyThreadState_GetDict();
  PyObject* result;
  bool err;

  if (dict == NULL)
    return NULL;
  if (key == NULL)
    {
      key = PyString_InternFromString("Psyco");
      if (key == NULL)
        return NULL;
    }
  result = PyDict_GetItem(dict, key);
  if (result == NULL)
    {
      result = PyDict_New();
      if (result == NULL)
        return NULL;
      err = PyDict_SetItem(dict, key, result);
      Py_DECREF(result);  /* one reference left in 'dict' */
      if (err)
        result = NULL;
    }
  return result;
}

#if CODE_DUMP
static void vinfo_array_dump(vinfo_array_t* array, FILE* f, PyObject* d)
{
  int i = array->count;
  fprintf(f, "%d\n", i);
  while (i--)
    {
      vinfo_t* vi = array->items[i];
      PyObject* key = PyInt_FromLong((long)vi);
      assert(key);
      fprintf(f, "%ld\n", (long)vi);
      if (vi != NULL && !PyDict_GetItem(d, key))
        {
          switch (gettime(vi->source)) {
          case CompileTime:
            fprintf(f, "ct %ld %ld\n",
                    CompileTime_Get(vi->source)->refcount1_flags,
                    CompileTime_Get(vi->source)->value);
            break;
          case RunTime:
            fprintf(f, "rt %ld\n", vi->source);
            break;
          case VirtualTime:
            fprintf(f, "vt 0x%lx\n", (long) VirtualTime_Get(vi->source));
            break;
          default:
            assert(0);
          }
          PyDict_SetItem(d, key, Py_None);
          vinfo_array_dump(vi->array, f, d);
        }
      Py_DECREF(key);
    }
}
DEFINEFN
void psyco_dump_code_buffers(void)
{
  FILE* f = fopen(CODE_DUMP_FILE, "wb");
  if (f != NULL)
    {
      CodeBufferObject* obj;
      PyObject *exc, *val, *tb;
      void** chain;
      int bufcount = 0;
      long* buftable;
#ifdef CODE_DUMP_SYMBOLS
      int i1;
      PyObject* global_addrs = PyDict_New();
      assert(global_addrs);
#endif
      PyErr_Fetch(&exc, &val, &tb);
      debug_printf(("psyco: writing " CODE_DUMP_FILE "\n"));

      for (obj=psyco_codebuf_chained_list; obj != NULL; obj=obj->chained_list)
        bufcount++;
      buftable = PyMem_NEW(long, bufcount);
      fwrite(&bufcount, sizeof(bufcount), 1, f);
      fwrite(buftable, sizeof(long), bufcount, f);

      /* give the address of an arbitrary symbol from the Python interpreter
         and from the Psyco module */
      fprintf(f, "PyInt_FromLong: 0x%lx\n", (long) &PyInt_FromLong);
      fprintf(f, "psyco_dump_code_buffers: 0x%lx\n",
              (long) &psyco_dump_code_buffers);

      for (obj=psyco_codebuf_chained_list; obj != NULL; obj=obj->chained_list)
        {
          int nsize = obj->codeend - obj->codeptr;
          PyCodeObject* co = obj->snapshot.fz_pyc_data ?
		  obj->snapshot.fz_pyc_data->co : NULL;
          fprintf(f, "CodeBufferObject 0x%lx %d %d '%s' '%s' %d '%s'\n",
                  (long) obj->codeptr, nsize, get_stack_depth(&obj->snapshot),
                  co?PyString_AsString(co->co_filename):"",
                  co?PyCodeObject_NAME(co):"",
                  co?obj->snapshot.fz_pyc_data->next_instr:-1,
                  obj->codemode);
          fwrite(obj->codeptr, 1, nsize, f);
#ifdef CODE_DUMP_SYMBOLS
          /* look-up all potential 'void*' pointers appearing in the code */
          for (i1=0; i1+sizeof(void*)<=nsize; i1++)
            {
              PyObject* key = PyInt_FromLong(*(long*)(obj->codeptr+i1));
              assert(key);
              PyDict_SetItem(global_addrs, key, Py_None);
              Py_DECREF(key);
            }
#endif
        }

      for (chain = psyco_codebuf_spec_dict_list; chain; chain=(void**)*chain)
        {
          PyObject* spec_dict = (PyObject*)(chain[-1]);
          int i = 0;
          PyObject *key, *value;
          fprintf(f, "spec_dict 0x%lx\n", (long) chain);
          while (PyDict_Next(spec_dict, &i, &key, &value))
            {
              PyObject* repr;
              if (PyInt_Check(key))
                {
#ifdef CODE_DUMP_SYMBOLS
                  PyDict_SetItem(global_addrs, key, Py_None);
#endif
                  repr = (key->ob_type->tp_as_number->nb_hex)(key);
                }
              else
                {
#ifdef CODE_DUMP_SYMBOLS
                  key = PyInt_FromLong((long) key);
                  assert(key);
                  PyDict_SetItem(global_addrs, key, Py_None);
#endif
                  repr = PyObject_Repr(key);
#ifdef CODE_DUMP_SYMBOLS
                  Py_DECREF(key);
#endif
                }
              assert(!PyErr_Occurred());
              assert(PyString_Check(repr));
              assert(CodeBuffer_Check(value));
              fprintf(f, "0x%lx %s\n", (long)((CodeBufferObject*)value)->codeptr,
                      PyString_AsString(repr));
              Py_DECREF(repr);
            }
          fprintf(f, "\n");
        }
#ifdef CODE_DUMP_SYMBOLS
      {
        int i = 0;
        PyObject *key, *value;
        fprintf(f, "symbol table\n");
        while (PyDict_Next(global_addrs, &i, &key, &value))
          {
            Dl_info info;
            void* ptr = (void*) PyInt_AS_LONG(key);
            if (dladdr(ptr, &info) && ptr == info.dli_saddr)
              fprintf(f, "0x%lx %s\n", (long) ptr, info.dli_sname);
          }
        Py_DECREF(global_addrs);
      }
#endif
      {
        int i = 0;
        fprintf(f, "vinfo_array\n");
        for (obj=psyco_codebuf_chained_list; obj != NULL; obj=obj->chained_list)
          {
            PsycoObject* live_po;
            PyObject* d;
            if (fz_top_array_count(&obj->snapshot) > 0)
              live_po = fpo_unfreeze(&obj->snapshot);
            else
              live_po = NULL;
            d = PyDict_New();
            assert(d);
            buftable[i++] = ftell(f);
            vinfo_array_dump(live_po ? &live_po->vlocals : NullArray, f, d);
            Py_DECREF(d);
            if (live_po)
              PsycoObject_Delete(live_po);
          }
        assert(i==bufcount);
        fseek(f, sizeof(bufcount), 0);
        fwrite(buftable, sizeof(long), bufcount, f);
      }
      PyMem_FREE(buftable);
      assert(!PyErr_Occurred());
      fclose(f);
      PyErr_Restore(exc, val, tb);
    }
}
static PyObject* Psyco_dumpcodebuf(PyObject* self, PyObject* args)
{
  psyco_dump_code_buffers();
  Py_INCREF(Py_None);
  return Py_None;
}
#endif  /* CODE_DUMP */

#if VERBOSE_LEVEL >= 4
DEFINEFN void psyco_trace_execution(char* msg, void* code_position)
{
  debug_printf(("psyco: trace %p for %s\n", code_position, msg));
}
DEFINEFN void psyco_trace_execution_noerr(char* msg, void* code_position)
{
  debug_printf(("psyco: trace %p for %s\n", code_position, msg));
  assert(!PyErr_Occurred());
}
#endif


/***************************************************************/
 /***   Replacements for PyEval_GetXxx()                      ***/

static PyObject* need_cpsyco_obj(char* name)
{
	PyObject* d = PyModule_GetDict(CPsycoModule);
	PyObject* result = PyDict_GetItemString(d, name);
	if (result == NULL)
		PyErr_Format(PyExc_PsycoError, "missing _psyco.%s", name);
	return result;
}

DEFINEFN PyFrameObject *
psyco_get_frame(int depth, struct stack_frame_info_s* psy_frame)
{
        /* Whenever we run Psyco-produced machine code, we mark the current
           Python frame as the starting point of a chained list of Psyco
           frames. The machine code will update this chained list so that
           psyco_next_stack_frame() can be used to visit the list from
           the outermost to the innermost frames. Note that the list does
           not contain the first Psyco frame, the one directly run by a
           call to psyco_processor_run(). This still gives the expected
           result, because PsycoFunctionObjects are only supposed to be
           called by proxy codes (see psyco_proxycode()). This proxy
           code itself has a frame. It replaces the missing Psyco frame.
           XXX this would no longer work if we filled the emulated frames
               with more information, like local variables */

	PyObject* finfo_start;
	PyObject* tdict = psyco_thread_dict();
	PyFrameObject* f = (PyFrameObject*) PyEval_GetFrame();

	while (f != NULL) {
		/* is this Python frame the starting point of a chained
		   list of Psyco frames ? */
		finfo_start = PyDict_GetItem(tdict, (PyObject*) f);
		if (finfo_start != NULL) {
			/* Yes. Get the list start. */
			stack_frame_info_t** finfo;
			stack_frame_info_t** f1;
                        PyCodeObject* f_code;
			PyObject* f_globals;
			long v;
			if (!PyArg_ParseTuple(finfo_start,
					      "lOO;corrupted dict", &v,
					      &f_code, &f_globals))
				return NULL;
			finfo = *((stack_frame_info_t***) v);

			/* Count the frames in the list. The end is marked by
			   a pointer with an odd integer value (actually the
			   least significant byte of the integer value is -1,
			   but real pointers cannot be odd at all because they
			   are aligned anyway). */
			for (f1 = finfo; (((long)(*f1)) & 1) == 0;
			     f1 = psyco_next_stack_frame(f1))
				depth--;

			if (depth < 0) {
				/* The requested frame is one of these Psyco
				   frames */
				while (++depth != 0)
					finfo = psyco_next_stack_frame(finfo);
				*psy_frame = **finfo;  /* copy structure */
				return f;
			}
			if (depth == 0) {
				/* the result is a real Python frame
				   shadowed by a Psyco frame, i.e. a
				   proxy function. */
				psy_frame->co = f_code;
				psy_frame->globals = f_globals;
				return f;
			}
		}
		if (depth-- == 0) {
			/* the result is a real Python frame */
			return f;
		}
		f = f->f_back;
	}
	PyErr_SetString(PyExc_ValueError, "call stack is not deep enough");
	return NULL;
}

DEFINEFN
PyObject* psyco_get_globals(void)
{
	PyFrameObject* f;
	stack_frame_info_t finfo;

        finfo.globals = NULL;
	f = psyco_get_frame(0, &finfo);
	if (f == NULL)
		return NULL;  /* error */
	
	if (finfo.globals != NULL)
		return finfo.globals;  /* from the Psyco frame */
	else
		return f->f_globals;   /* Python frame, or no Psyco globals */
}

static PyObject* psyco_get_locals_msg(char* msg)
{
	PyFrameObject* f;
	stack_frame_info_t finfo;

        finfo.co = NULL;
	f = psyco_get_frame(0, &finfo);
	if (f == NULL)
		return NULL;  /* error */
	
	if (finfo.co != NULL) {
		/* it is a Psyco frame -- no locals available */
		PyObject* w = need_cpsyco_obj("NoLocalsWarning");
		if (w == NULL)
			return NULL;
		PyErr_Warn(w, msg);
		return PyDict_New();
	}
	else {
		PyFrame_FastToLocals(f);
		return f->f_locals;
	}
}

DEFINEFN
PyObject* psyco_get_locals(void)
{
	return psyco_get_locals_msg("no locals() in functions bound by Psyco");
}

#define WARN_IMPLICIT_LOCALS " cannot see the locals in functions bound by " \
                             "Psyco; consider using eval() in its two- or " \
                             "three-arguments form"

/*****************************************************************/

static PyObject* Psyco_proxycode(PyObject* self, PyObject* args)
{
	int recursion = DEFAULT_RECURSION;
	PyFunctionObject* function;
	
	if (!PyArg_ParseTuple(args, "O!|i",
			      &PyFunction_Type, &function,
			      &recursion))
		return NULL;

	return psyco_proxycode(function, recursion);
}

static PyObject* Psyco_unproxycode(PyObject* self, PyObject* args)
{
	PyCodeObject* code;
	PsycoFunctionObject* proxy;
	PyObject* func;
	
	if (!PyArg_ParseTuple(args, "O!", &PyCode_Type, &code))
		return NULL;

	if (!is_proxycode(code)) {
		PyErr_SetString(PyExc_PsycoError, "code object is not a proxy");
		return NULL;
	}
	proxy = (PsycoFunctionObject*) PyTuple_GET_ITEM(code->co_consts, 1);
	
	func = PyFunction_New((PyObject*) proxy->psy_code, proxy->psy_globals);
	if (func == NULL)
		return NULL;
	if (proxy->psy_defaults != NULL &&
	    PyFunction_SetDefaults(func, proxy->psy_defaults)) {
		Py_DECREF(func);
		return NULL;
	}
	return func;
}

/* replacement for sys._getframe() */
static PyObject* Psyco_getframe(PyObject* self, PyObject* args)
{
	PyFrameObject* f;
	stack_frame_info_t finfo;
	int depth = 0;
	int emulate = 1;
	if (!PyArg_ParseTuple(args, "|ii:_getframe", &depth, &emulate))
		return NULL;

        finfo.co = NULL;
	f = psyco_get_frame(depth, &finfo);
	if (f != NULL) {
		if (finfo.co != NULL) {
			/* a Psyco frame; emulate it */
			if (emulate)
				f = psyco_emulate_frame(&finfo, f->f_globals);
			else {
				Py_INCREF(Py_None);
				return Py_None;
			}
		}
		else {
			/* a real Python frame */
			Py_INCREF(f);
		}
	}
	return (PyObject*) f;
}

/* replacement for __builtin__.globals() */
static PyObject *
Psyco_globals(PyObject* self, PyObject* args)
{
	PyObject *d;

	if (!PyArg_ParseTuple(args, ":globals"))
		return NULL;
	d = psyco_get_globals();
	Py_INCREF(d);
	return d;
}

/* replacement for __builtin__.locals() */
static PyObject *
Psyco_locals(PyObject* self, PyObject* args)
{
	PyObject* d;

	if (!PyArg_ParseTuple(args, ":locals"))
		return NULL;
	d = psyco_get_locals();
	Py_INCREF(d);
	return d;
}

static PyObject* builtinevaluator(PyObject* args, char* oname)
{
	PyObject *o;
	PyObject *cmd;
	PyObject *globals = Py_None, *locals = Py_None;

	o = need_cpsyco_obj(oname);
	if (o == NULL)
		return NULL;

	if (!PyArg_ParseTuple(args, "O|O!O!",
			&cmd,
			&PyDict_Type, &globals,
			&PyDict_Type, &locals)) {
		/* let the original function report the problem, if any */
		PyErr_Clear();
	}
	else if (globals == Py_None) {
		globals = psyco_get_globals();
		if (locals == Py_None)
			locals = psyco_get_locals_msg("eval()/execfile()"
						      WARN_IMPLICIT_LOCALS);
		return PyObject_CallFunction(o, "OOO", cmd, globals, locals);
	}

	/* fallback */
	return PyObject_CallObject(o, args);
}

/* replacement for __builtin__.eval() */
static PyObject *
Psyco_eval(PyObject* self, PyObject* args)
{
	return builtinevaluator(args, "original_eval");
}

/* replacement for __builtin__.execfile() */
static PyObject *
Psyco_execfile(PyObject *self, PyObject *args)
{
	return builtinevaluator(args, "original_execfile");
}

/* replacement for __builtin__.vars() */
static PyObject *
Psyco_vars(PyObject *self, PyObject *args)
{
	PyObject* o;
	if (PyTuple_Size(args) == 0) {
		PyObject* d = psyco_get_locals();
		Py_INCREF(d);
		return d;
	}
	/* fallback */
	o = need_cpsyco_obj("original_vars");
	if (o == NULL)
		return NULL;
	return PyObject_CallObject(o, args);
}

/* replacement for __builtin__.dir() */
static PyObject *
Psyco_dir(PyObject *self, PyObject *args)
{
	PyObject* o;
	if (PyTuple_Size(args) == 0) {
		PyObject* locals = psyco_get_locals();
		PyObject* result = PyDict_Keys(locals);
		if (PyList_Sort(result) != 0) {
			Py_XDECREF(result);
			result = NULL;
		}
		return result;
	}
	/* fallback */
	o = need_cpsyco_obj("original_dir");
	if (o == NULL)
		return NULL;
	return PyObject_CallObject(o, args);
}

/* replacement for __builtin__.input() */
static PyObject *
Psyco_input(PyObject *self, PyObject *args)
{
	PyObject* cmd;
	PyObject* o = need_cpsyco_obj("original_raw_input");
	if (o == NULL)
		return NULL;

	cmd = PyObject_CallObject(o, args);
	if (cmd != NULL) {
		PyObject* globals = psyco_get_globals();
		PyObject* locals = psyco_get_locals_msg("input()"
							WARN_IMPLICIT_LOCALS);
		o = need_cpsyco_obj("original_eval");
		if (o == NULL)
			return NULL;
		return PyObject_CallFunction(o, "OOO", cmd, globals, locals);
	}
	/* fallback */
	o = need_cpsyco_obj("original_dir");
	if (o == NULL)
		return NULL;
	return PyObject_CallObject(o, args);
}

/* Initialize selective compilation */
static PyObject* Psyco_selective(PyObject* self, PyObject* args)
{
  if (!PyArg_ParseTuple(args, "i", &ticks)) {
    return NULL;
  }

  /* Sanity check argument */
  if (ticks < 0) {
    PyErr_SetString(PyExc_ValueError, "negative ticks");
    return NULL;
  }

  /* Enable our selective compilation function */
  if (psyco_start_selective())
    return NULL;
  
  Py_INCREF(Py_None);
  return Py_None;
}

/*****************************************************************/

static char proxycode_doc[] =
"proxycode(func[, rec]) -> code object\n\
\n\
Return a proxy code object that invokes Psyco on the argument. The code\n\
object can be used to replace func.func_code. Raise psyco.error if func\n\
uses unsupported features. Return func.func_code itself if it is already\n\
a proxy code object. The optional second argument specifies the number of\n\
recursive compilation levels: all functions called by func are compiled\n\
up to the given depth of indirection.";

static char unproxycode_doc[] =
"unproxycode(code) -> function object\n\
\n\
Return a new copy of the original function that was used to build the\n\
given proxy code object. Raise psyco.error if code is not a proxy.";

static char getframe_doc[] =
"_getframe([depth]) -> frameobject\n\
\n\
Return a frame object from the call stack. This is a replacement for the\n\
original sys._getframe() function that can return Psyco frames as well.\n\
When imported, Psyco installs this function as sys._getframe() and stores\n\
the original function in psyco.original_sys_getframe().\n\
\n\
Note that the Python frame emulation is partial. In particular, do not\n\
use the f_back fields but always call _getframe() to parse the whole\n\
stack.";

static char globals_doc[] =
"globals() -> dictionary\n\
\n\
Return the dictionary containing the current scope's global variables.\n\
This is the Psyco-aware version.";

static char gennolocals_doc[] =
"This is the Psyco-aware version of the builtin function of the same name.\n\
For more information see psyco._psyco.original_<<<function name>>>.__doc__.\n\
\n\
Functions have no locals() dictionary with Psyco.\n\
Accessing it returns {} and throws a NoLocalsWarning.";

static PyMethodDef PsycoMethods[] = {
	{"proxycode",	&Psyco_proxycode,	METH_VARARGS,	proxycode_doc},
	{"unproxycode",	&Psyco_unproxycode,	METH_VARARGS,	unproxycode_doc},
        {"_getframe",	&Psyco_getframe,	METH_VARARGS,	getframe_doc},
        {"globals",	&Psyco_globals,		METH_VARARGS,	globals_doc},
	{"eval",	&Psyco_eval,		METH_VARARGS,	gennolocals_doc},
	{"execfile",	&Psyco_execfile,	METH_VARARGS,	gennolocals_doc},
	{"locals",	&Psyco_locals,		METH_VARARGS,	gennolocals_doc},
	{"vars",	&Psyco_vars,		METH_VARARGS,	gennolocals_doc},
	{"dir",		&Psyco_dir,		METH_VARARGS,	gennolocals_doc},
	{"input",	&Psyco_input,		METH_VARARGS,	gennolocals_doc},
	{"selective",	&Psyco_selective,	METH_VARARGS},
#if CODE_DUMP
	{"dumpcodebuf",	&Psyco_dumpcodebuf,	METH_VARARGS},
#endif
	{NULL,		NULL}        /* Sentinel */
};

/* Initialization */
void init_psyco(void)
{
  PsycoFunction_Type.ob_type = &PyType_Type;
  CodeBuffer_Type.ob_type = &PyType_Type;

  CPsycoModule = Py_InitModule("_psyco", PsycoMethods);
  if (CPsycoModule == NULL)
    return;
  PyExc_PsycoError = PyErr_NewException("psyco.error", NULL, NULL);
  if (PyExc_PsycoError == NULL)
    return;
  if (PyModule_AddObject(CPsycoModule, "error", PyExc_PsycoError))
    return;
  Py_INCREF(&PsycoFunction_Type);
  if (PyModule_AddObject(CPsycoModule, "PsycoFunctionType",
			 (PyObject*) &PsycoFunction_Type))
    return;
  if (PyModule_AddIntConstant(CPsycoModule, "DEFAULT_RECURSION", DEFAULT_RECURSION))
    return;
#if ALL_CHECKS
  if (PyModule_AddIntConstant(CPsycoModule, "ALL_CHECKS", ALL_CHECKS))
    return;
#endif
#if VERBOSE_LEVEL
  if (PyModule_AddIntConstant(CPsycoModule, "VERBOSE_LEVEL", VERBOSE_LEVEL))
    return;
#endif
#ifdef PY_PSYCO_MODULE
  PyPsycoModule = PyImport_ImportModule("psyco");
  if (PyPsycoModule == NULL)
    return;
#endif

  initialize_all_files();
}
